#!/usr/bin/env node
/**
 * Terminal Client for Agent Swarm Protocol
 * A command-line interface to interact with the ASP Orchestrator
 * Using the SwarmClientSDK
 */

const readline = require('readline');
const { v4: uuidv4 } = require('uuid');
const SwarmClientSDK = require('../sdk/clientsdk');
const { select, input } = require('@inquirer/prompts');
require('dotenv').config({ path: '../.env' });

// Configuration
const ORCHESTRATOR_URL = process.env.ORCHESTRATOR_CLIENT_URL || 'ws://localhost:3001';

// Create CLI interface
const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout
});

// Client state
const state = {
  running: false,
  agents: [],
  tasks: {},
  mcpServers: [],
  client: null,
  chatState: {
    inChatSession: false,
    currentAgent: null,
    conversationId: null,
    messageHistory: [],
    initTaskId: null,
    currentTaskId: null,
    directResponseListener: null
  }
};

// Helper for asking questions
function ask(question) {
  return new Promise(resolve => {
    rl.question(question, answer => {
      resolve(answer);
    });
  });
}

// Connect to the orchestrator
async function connect() {  
  try {
    // Initialize the client SDK
    state.client = new SwarmClientSDK({
      orchestratorUrl: ORCHESTRATOR_URL,
      autoReconnect: true
    });
    
    // Set up event handlers
    state.client.on('connected', () => {
      console.log('Connected to orchestrator');
    });
    
    state.client.on('disconnected', () => {
      console.log('Disconnected from orchestrator');
      
      // Ask to reconnect if not exiting
      if (state.running) {
        console.log('Connection closed. Reconnect? (y/n)');
        ask('> ').then(answer => {
          if (answer.toLowerCase() === 'y') {
            connect().catch(error => {
              console.error('Failed to reconnect:', error);
              state.running = false;
              rl.close();
            });
          } else {
            state.running = false;
            rl.close();
          }
        });
      }
    });
    
    state.client.on('welcome', (content) => {
      console.log(`Connected as client: ${content.clientId}`);
    });
    
    state.client.on('agent-list', (agents) => {
      state.agents = agents;
      displayAgentList();
    });
    
    state.client.on('task-result', (content) => {
      console.log(`Received task result for task ID: ${content.taskId}`);
      
      // If we're in a chat session, handle differently
      if (state.chatState.inChatSession) {
        // Check if this is our current chat task
        if (content.taskId === state.chatState.currentTaskId) {
          handleChatResponse(content);
          return;
        }
        
        // Check if this is our initialization task
        if (content.taskId === state.chatState.initTaskId) {
          console.log(`Received delayed initialization response for task ID: ${content.taskId}`);
          if (content.result && content.result.response) {
            console.log('\n');
            console.log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
            console.log(`🤖 ${state.chatState.currentAgent.name}:`);
            console.log(content.result.response);
            console.log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
            console.log('\nType your message or "exit" to end the conversation:');
            process.stdout.write('> ');
          }
          return;
        }
      }

      console.log('\n✅ Task completed!');
      console.log('Result:', JSON.stringify(content.result, null, 2));
      
      // Store task result
      if (content.taskId) {
        state.tasks[content.taskId] = {
          status: 'completed',
          result: content.result,
          completedAt: new Date().toISOString()
        };
      }
    });
    
    state.client.on('task-created', (content) => {
      // If we're in a chat session, don't output this
      if (state.chatState.inChatSession && (content.taskId === state.chatState.currentTaskId || content.taskId === state.chatState.initTaskId)) {
        return;
      }

      console.log(`\nTask created with ID: ${content.taskId}`);
      console.log(`Status: ${content.status}`);
      
      // Store task info
      if (content.taskId) {
        state.tasks[content.taskId] = {
          status: content.status,
          createdAt: new Date().toISOString()
        };
      }
    });
    
    state.client.on('task-status', (content) => {
      // If we're in a chat session, don't display this
      if (state.chatState.inChatSession && (content.taskId === state.chatState.currentTaskId || content.taskId === state.chatState.initTaskId)) {
        return;
      }
      displayTaskStatus(content);
    });
    
    state.client.on('orchestrator-error', (content) => {
      console.error('\n❌ Error:', content.error || 'Unknown error');
      if (content.details) {
        console.error('Details:', content.details);
      }
    });
    
    state.client.on('message', (message) => {
      if (state.chatState.inChatSession) {
        // For debugging
        if (message.type !== 'task.created' && message.type !== 'pong') {
          console.log(`Debug - received message in chat: ${JSON.stringify(message)}`);
        }
      } else {
        displayPrompt();
      }
    });
    
    state.client.on('error', (error) => {
      console.error('Client error:', error.message || error);
    });
    
    state.client.on('mcp-server-list', (servers) => {
      state.mcpServers = servers;
      displayMCPServersList();
    });
    
    state.client.on('mcp-server-registered', (content) => {
      console.log('\nMCP Server registered:');
      console.log(`Server ID: ${content.serverId}`);
      console.log(`Name: ${content.name}`);
      console.log(`Status: ${content.status}`);
      
      // Update the servers list
      listMCPServers();
    });
    
    // Connect to the orchestrator
    await state.client.connect();
    return true;
  } catch (error) {
    console.error(`Failed to connect: ${error.message || error}`);
    return false;
  }
}

// Display the agent list
function displayAgentList() {
  console.log('\nAvailable Agents:');
  console.log('--------------------------------------------------------------');
  console.log('ID\t\t\t\tName\t\tStatus\tCapabilities');
  console.log('--------------------------------------------------------------');
  
  if (state.agents.length === 0) {
    console.log('No agents registered yet.');
  } else {
    state.agents.forEach(agent => {
      console.log(
        `${agent.id.substring(0, 8)}...\t${agent.name}\t\t${agent.status}\t${agent.capabilities.join(', ')}`
      );
    });
  }
  
  console.log('--------------------------------------------------------------');
}

// Display MCP servers list
function displayMCPServersList() {
  console.log('\nAvailable MCP Servers:');
  console.log('--------------------------------------------------------------');
  console.log('ID\t\t\t\tName\t\tStatus\tType');
  console.log('--------------------------------------------------------------');
  
  if (state.mcpServers.length === 0) {
    console.log('No MCP servers registered yet.');
  } else {
    state.mcpServers.forEach(server => {
      const id = server.id.substring(0, 8) + '...';
      const name = server.name.length > 12 ? server.name.substring(0, 12) + '...' : server.name;
      const status = server.status || 'registered';
      const type = server.type || 'unknown';
      
      console.log(`${id}\t${name}\t\t${status}\t${type}`);
    });
  }
  
  console.log('--------------------------------------------------------------');
}

// Display task status
function displayTaskStatus(taskInfo) {
  console.log('\nTask Status:');
  console.log('--------------------------------------------------------------');
  console.log(`Task ID: ${taskInfo.taskId}`);
  console.log(`Status: ${taskInfo.status}`);
  console.log(`Created: ${taskInfo.createdAt}`);
  
  if (taskInfo.completedAt) {
    console.log(`Completed: ${taskInfo.completedAt}`);
  }
  
  if (taskInfo.result) {
    console.log('\nResult:');
    console.log(JSON.stringify(taskInfo.result, null, 2));
  }
  
  console.log('--------------------------------------------------------------');
}

// Display the command prompt
function displayPrompt() {
  process.stdout.write('\n> ');
}

// Send a task to an agent
async function sendTask() {
  try {
    // If no agents are loaded, get the list first
    if (state.agents.length === 0) {
      await listAgents();
    }
    
    if (state.agents.length === 0) {
      console.log('❌ No agents available');
      return;
    }
    
    // Get online agents
    const onlineAgents = state.agents.filter(agent => agent.status === 'online');
    
    if (onlineAgents.length === 0) {
      console.log('❌ No online agents available for tasks');
      return;
    }

    // Create agent choices for inquirer
    const agentChoices = onlineAgents.map(agent => ({
      name: `${agent.name} (${agent.capabilities.join(', ')})`,
      value: agent
    }));

    // Temporary pause readline to avoid conflicts with inquirer
    rl.pause();

    // Select an agent using inquirer
    const selectedAgent = await select({
      message: 'Select an agent to send a task to:',
      choices: agentChoices
    });

    // Resume readline
    rl.resume();
    
    console.log(`\nSelected agent: ${selectedAgent.name}`);
    
    // Get task data
    console.log('\nEnter task data as JSON (or "cancel" to abort):');
    console.log('Example: { "taskType": "text-processing", "text": "Hello, world!" }');
    const taskDataStr = await ask('Task data: ');
    
    if (taskDataStr.toLowerCase() === 'cancel') {
      console.log('Task sending cancelled');
      return;
    }
    
    let taskData;
    try {
      taskData = JSON.parse(taskDataStr);
    } catch (error) {
      console.error('❌ Invalid JSON:', error.message);
      return;
    }
    
    // Pause readline for inquirer
    rl.pause();
    
    // Ask if we should wait for the result using inquirer
    const waitForResult = await select({
      message: 'Wait for task result?',
      choices: [
        { name: 'Yes', value: true },
        { name: 'No', value: false }
      ]
    });
    
    // Resume readline
    rl.resume();
    
    // Send the task using the SDK
    console.log(`\nSending task to agent ${selectedAgent.name}...`);
    const response = await state.client.sendTask(selectedAgent.name, taskData, { 
      waitForResult,
      timeout: 60000 // 60 second timeout
    });
    
    // Store task for future reference
    if (response.taskId) {
      state.tasks[response.taskId] = {
        agentName: selectedAgent.name,
        status: response.status,
        result: response.result,
        createdAt: new Date().toISOString(),
        taskData
      };
      
      if (response.status === 'completed') {
        state.tasks[response.taskId].completedAt = new Date().toISOString();
      }
      
      console.log(`\nTask ID: ${response.taskId}`);
      console.log(`Status: ${response.status}`);
      
      if (response.result) {
        console.log('\nResult:');
        console.log(JSON.stringify(response.result, null, 2));
      }
    }
    
  } catch (error) {
    console.error('❌ Error sending task:', error.message);
  }
}

// Handle chat response from agent
function handleChatResponse(content) {
  console.log(`Processing chat response for task ID: ${content.taskId}`);
  
  // Debug: log the full content to understand its structure
  console.log(`Response content: ${JSON.stringify(content, null, 2)}`);
  
  let response = null;
  
  // Handle different response formats
  if (content.result) {
    if (content.result.response) {
      response = content.result.response;
    } else if (content.result.message) {
      response = content.result.message;
    } else if (typeof content.result === 'string') {
      response = content.result;
    }
  } else if (content.response) {
    response = content.response;
  } else if (content.message) {
    response = content.message;
  }
  
  if (!response) {
    console.log("\n❌ Agent didn't provide a valid response format");
    console.log("Please check the agent implementation to ensure it returns a response in the expected format.");
    console.log('\nType your message or "exit" to end the conversation:');
    process.stdout.write('> ');
    return;
  }

  // Add response to message history
  state.chatState.messageHistory.push({
    role: 'assistant',
    content: response
  });

  // Display agent's response in a formatted way
  console.log('\n');
  console.log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
  console.log(`🤖 ${state.chatState.currentAgent.name}:`);
  console.log(response);
  console.log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
  
  // Prompt for the next message
  console.log('\nType your message or "exit" to end the conversation:');
  process.stdout.write('> ');
}

// Start a chat session with an agent
async function startChatSession() {
  try {
    // If no agents are loaded, get the list first
    if (state.agents.length === 0) {
      await listAgents();
    }
    
    if (state.agents.length === 0) {
      console.log('❌ No agents available for chat');
      return;
    }
    
    // Get online agents
    const onlineAgents = state.agents.filter(agent => agent.status === 'online');
    
    if (onlineAgents.length === 0) {
      console.log('❌ No online agents available for chat');
      return;
    }

    // Create agent choices for inquirer
    const agentChoices = onlineAgents.map(agent => ({
      name: `${agent.name} (${agent.capabilities.join(', ')})`,
      value: agent
    }));

    // Temporary pause readline to avoid conflicts with inquirer
    rl.pause();

    // Select an agent using inquirer
    const selectedAgent = await select({
      message: 'Select an agent to chat with:',
      choices: agentChoices
    });

    // Resume readline
    rl.resume();
    
    console.log(`\nStarting chat session with ${selectedAgent.name}...`);
    
    // Create a unique conversation ID
    const conversationId = uuidv4();
    
    // Update chat state
    state.chatState = {
      inChatSession: true,
      currentAgent: selectedAgent,
      conversationId: conversationId,
      messageHistory: [],
      initTaskId: null,
      currentTaskId: null,
      directResponseListener: null
    };
    
    console.log('\n╔════════════════════════════════════════════════════════════════╗');
    console.log(`║ Chat session with ${selectedAgent.name}`);
    console.log('║ Type "exit" at any time to end the conversation');
    console.log('╚════════════════════════════════════════════════════════════════╝');
    
    // Set up direct response listener to catch all potential responses
    state.chatState.directResponseListener = (message) => {
      if (!state.chatState.inChatSession) return;
      
      // Check if this could be a response to our chat tasks
      if (message.type === 'task.result' && 
          (message.content.taskId === state.chatState.currentTaskId || 
          message.content.taskId === state.chatState.initTaskId)) {
        
        console.log(`Direct listener caught task result for ${message.content.taskId}`);
        if (message.content.taskId === state.chatState.currentTaskId) {
          handleChatResponse(message.content);
        } else if (message.content.taskId === state.chatState.initTaskId) {
          // Handle initialization response
          if (message.content.result && message.content.result.response) {
            console.log('\n');
            console.log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
            console.log(`🤖 ${state.chatState.currentAgent.name}:`);
            console.log(message.content.result.response);
            console.log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
            console.log('\nType your message or "exit" to end the conversation:');
            process.stdout.write('> ');
          }
        }
      }
    };
    
    // Add the direct listener for all messages
    state.client.on('message', state.chatState.directResponseListener);
    
    // Start the conversation with the agent
    try {
      console.log('\nInitializing conversation...');
      
      // Send a conversation:start task to initialize the chat
      const startTaskData = {
        taskType: 'conversation:start',
        conversationId: conversationId,
        context: {
          userData: {
            clientId: state.client.clientId,
            preferences: {
              formality: 'balanced',
              verbosity: 'balanced'
            }
          }
        }
      };
      
      // Add an event listener specifically for this task result
      let initTaskCompleted = false;
      const initTaskListener = (content) => {
        if (content.taskId && state.chatState.initTaskId === content.taskId) {
          initTaskCompleted = true;
          
          if (content.result && content.result.response) {
            // Add agent's greeting to message history
            state.chatState.messageHistory.push({
              role: 'assistant',
              content: content.result.response
            });
            
            // Display agent's greeting
            console.log('\n');
            console.log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
            console.log(`🤖 ${selectedAgent.name}:`);
            console.log(content.result.response);
            console.log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
          }
        }
      };
      
      // Add the listener for task results
      state.client.on('task-result', initTaskListener);
      
      // Send the initialization task 
      try {
        const initResponse = await state.client.sendTask(selectedAgent.name, startTaskData, { waitForResult: false });
        state.chatState.initTaskId = initResponse.taskId;
        console.log(`Initialization task sent with ID: ${initResponse.taskId}`);
        
        // Wait up to 5 seconds for the initialization response
        let timeoutCount = 0;
        while (!initTaskCompleted && timeoutCount < 10) {
          await new Promise(resolve => setTimeout(resolve, 500));
          timeoutCount++;
        }
        
        // Remove the listener once we're done with initialization
        state.client.removeListener('task-result', initTaskListener);
        
        if (!initTaskCompleted) {
          console.log("\nAgent didn't respond to initialization request, but we can still try to chat.");
          console.log("The agent may still be processing or might respond later.");
        }
      } catch (error) {
        console.error(`\n❌ Error sending initialization task: ${error.message}`);
        state.client.removeListener('task-result', initTaskListener);
      }
      
    } catch (error) {
      console.error(`\n❌ Error initializing conversation: ${error.message}`);
    }
    
    // Prompt for the first message
    console.log('\nType your message:');
    process.stdout.write('> ');
    
    // Create a temporary readline interface just for chat
    const chatRl = readline.createInterface({
      input: process.stdin,
      output: process.stdout
    });
    
    // Handle chat input
    chatRl.on('line', async (line) => {
      const message = line.trim();
      
      // Check if user wants to exit the chat
      if (message.toLowerCase() === 'exit') {
        console.log('\nEnding chat session...');
        
        // Send conversation:end message
        try {
          await state.client.sendTask(selectedAgent.name, {
            taskType: 'conversation:end',
            conversationId: state.chatState.conversationId
          }, { waitForResult: false });
        } catch (error) {
          console.error(`\n❌ Error ending conversation: ${error.message}`);
        }
        
        // Remove direct response listener
        if (state.chatState.directResponseListener) {
          state.client.removeListener('message', state.chatState.directResponseListener);
        }
        
        state.chatState.inChatSession = false;
        chatRl.close();
        displayPrompt();
        return;
      }
      
      // Add message to history
      state.chatState.messageHistory.push({
        role: 'user',
        content: message
      });
      
      // Prepare chat task data using the correct format for ConversationAgent
      const taskData = {
        taskType: 'conversation:message',
        conversationId: state.chatState.conversationId,
        message: message,
        context: {
          messageHistory: state.chatState.messageHistory
        }
      };
      
      try {
        // Send message to agent
        console.log('\nSending message to agent...');
        
        // Send the task using the SDK
        const response = await state.client.sendTask(selectedAgent.name, taskData, { waitForResult: false });
        
        // Store current task ID for tracking responses
        state.chatState.currentTaskId = response.taskId;
        console.log(`Message sent with task ID: ${response.taskId}`);
        
      } catch (error) {
        console.error(`\n❌ Error sending message: ${error.message}`);
        console.log('\nType your message or "exit" to end the conversation:');
        process.stdout.write('> ');
      }
    });
    
    // Handle chat session cleanup when readline closes
    chatRl.on('close', () => {
      if (state.chatState.inChatSession) {
        // Remove direct response listener
        if (state.chatState.directResponseListener) {
          state.client.removeListener('message', state.chatState.directResponseListener);
        }
        
        state.chatState.inChatSession = false;
        console.log('\nChat session ended.');
        displayPrompt();
      }
    });
    
  } catch (error) {
    console.error('❌ Error starting chat session:', error.message);
    state.chatState.inChatSession = false;
  }
}

// Check task status
async function checkTaskStatus() {
  try {
    const taskId = await ask('Enter task ID: ');
    
    if (!taskId) {
      console.log('Operation cancelled');
      return;
    }
    
    // Send task status request using the SDK
    console.log(`Checking status for task ${taskId}...`);
    const status = await state.client.getTaskStatus(taskId);
    
    // Store task info
    if (status) {
      state.tasks[taskId] = {
        ...state.tasks[taskId],
        ...status
      };
    }
    
  } catch (error) {
    console.error('❌ Error checking task status:', error.message);
  }
}

// List available agents
async function listAgents() {
  try {
    console.log('Fetching agent list...');
    state.agents = await state.client.getAgents();
    displayAgentList();
    return state.agents;
  } catch (error) {
    console.error('❌ Error fetching agents:', error.message);
    return [];
  }
}

// List available MCP servers
async function listMCPServers() {
  try {
    console.log('Fetching MCP servers list...');
    const response = await state.client.sendAndWaitForResponse({
      type: 'mcp.server.list',
      content: { filters: {} }
    });
    
    console.log('Received MCP servers response:', JSON.stringify(response));
    
    if (response && response.content && response.content.servers) {
      state.mcpServers = response.content.servers;
      displayMCPServersList();
    } else {
      console.log('No MCP servers data in response');
      state.mcpServers = [];
      displayMCPServersList();
    }
    
    return response.content?.servers || [];
  } catch (error) {
    console.error('❌ Error fetching MCP servers:', error.message || error);
    state.mcpServers = [];
    displayMCPServersList();
    return [];
  }
}

// Register an MCP server
async function registerMCPServer() {
  console.log('❌ MCP server registration through terminal client is no longer supported.');
  console.log('Please use orchestrator configuration files to configure MCP servers.');
}

// Show help information
function showHelp() {
  console.log('\nAgent Swarm Protocol Terminal Client');
  console.log('=======================================================');
  console.log('Available commands:');
  console.log('  agents     - List available agents');
  console.log('  task       - Send a task to an agent');
  console.log('  chat       - Start a chat session with an agent');
  console.log('  status     - Check task status');
  console.log('  mcp        - List available MCP servers');
  console.log('  help       - Show this help message');
  console.log('  exit       - Exit the client');
  console.log('=======================================================');
}

// Main function
async function main() {
  state.running = true;
  
  console.log('\nAgent Swarm Protocol Terminal Client');
  console.log('Type "help" to see available commands.');
  
  const connected = await connect();
  if (!connected) {
    console.log('Failed to connect to orchestrator. Exiting...');
    state.running = false;
    rl.close();
    return;
  }
  
  displayPrompt();
  
  rl.on('line', async (line) => {
    // If we're in a chat session, let the chat handler deal with input
    if (state.chatState.inChatSession) {
      return;
    }

    const command = line.trim().toLowerCase();
    
    try {
      switch (command) {
        case 'agents':
          await listAgents();
          break;
          
        case 'task':
          await sendTask();
          break;
          
        case 'chat':
          await startChatSession();
          break;
          
        case 'status':
          await checkTaskStatus();
          break;
          
        case 'mcp':
          await listMCPServers();
          break;
          
        case 'help':
          showHelp();
          break;
          
        case 'exit':
          console.log('Exiting...');
          state.running = false;
          if (state.client) {
            state.client.disconnect();
          }
          rl.close();
          return;
          
        case '':
          // Ignore empty lines
          break;
          
        default:
          console.log(`Unknown command: ${command}`);
          console.log('Type "help" to see available commands.');
      }
    } catch (error) {
      console.error(`Error executing command: ${error.message}`);
    }
    
    displayPrompt();
  });
}

// Run the client
main().catch(error => {
  console.error('Fatal error:', error);
  process.exit(1);
}); 